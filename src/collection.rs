//! # `DBus` interface proxy for: `org.a11y.atspi.Collection`
//!
//! This code was generated by `zbus-xmlgen` `2.0.1` from `DBus` introspection data.
//! Source: `Collection.xml`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the
//! [Writing a client proxy](https://dbus.pages.freedesktop.org/zbus/client.html)
//! section of the zbus documentation.
//!
#![allow(clippy::too_many_arguments)]
// this allow zbus to change the number of parameters in a function without setting off clippy

use std::{collections::HashMap, marker::PhantomData};

use crate::{accessible::Role, atspi_proxy, Interface, InterfaceSet, StateSet};
use serde::{Deserialize, Serialize};
use zbus::zvariant::Type;

/// Rule(s) against which we can match a collection of objects.
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct MatchRule {
	pub states: StateSet,
	pub states_mt: MatchType,
	pub attr: HashMap<String, String>,
	pub attr_mt: MatchType,
	pub roles: Vec<Role>,
	pub roles_mt: MatchType,
	pub ifaces: InterfaceSet,
	pub ifaces_mt: MatchType,
	pub invert: bool,
	// Private phantom, gets compiled away.
	// Here to ensure the builder is the only route to obtain a `MatchRule`
	#[serde(skip)]
	phantom: std::marker::PhantomData<()>,
}

//  TODO: Can we (easily) tie this to the XML defined signature directly?
#[test]
fn match_rule_derived_dbus_signature_corresponds_xml_signature() {
	let signature = MatchRule::signature();
	assert_eq!("(aiia{ss}iaiiasib)", signature.as_str())
}

/// The 'builder' type for `MatchRule`.
/// Use its methods to set match criteria.
#[derive(Debug, Clone, Default)]
pub struct MatchRuleBuilder {
	states: StateSet,
	states_mt: MatchType,
	attr: HashMap<String, String>,
	attr_mt: MatchType,
	roles: Vec<Role>,
	roles_mt: MatchType,
	ifaces: InterfaceSet,
	ifaces_mt: MatchType,
	invert: bool,
}

impl MatchRule {
	pub fn builder() -> MatchRuleBuilder {
		MatchRuleBuilder::default()
	}
}

impl MatchRuleBuilder {
	/// Insert a `StateSet` to the builder
	pub fn states(mut self, state_set: StateSet, mt: MatchType) -> Self {
		self.states = state_set;
		self.states_mt = mt;
		self
	}

	// TODO: Add method to add add a single state
	// check if the StateSet is Some, add it, else create and add it.

	/// Insert a map of attributes
	pub fn attributes(mut self, attributes: HashMap<String, String>, mt: MatchType) -> Self {
		self.attr = attributes;
		self.attr_mt = mt;
		self
	}

	// TODO: Add method for single attribute, see SateSet comment

	/// Insert a slice of `Role`s
	pub fn roles(mut self, roles: &[Role], mt: MatchType) -> Self {
		self.roles = roles.into();
		self.roles_mt = mt;
		self
	}

	// TODO: Add method for single Role, see SateSet comment

	/// Insert a slice of `Interface`s
	pub fn interfaces(mut self, interfaces: &[Interface], mt: MatchType) -> Self {
		self.ifaces = interfaces.into();
		self.ifaces_mt = mt;
		self
	}

	/// Sets the inversion of the `MatchRule`, defaults to `false`, no inversion.
	pub fn invert(mut self, invert: bool) -> Self {
		self.invert = invert;
		self
	}

	pub fn build(self) -> MatchRule {
		MatchRule {
			states: self.states,
			states_mt: self.states_mt,
			attr: self.attr,
			attr_mt: self.attr_mt,
			roles: self.roles,
			roles_mt: self.roles_mt,
			ifaces: self.ifaces,
			ifaces_mt: self.ifaces_mt,
			invert: self.invert,
			phantom: PhantomData,
		}
	}
}

#[non_exhaustive]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize, Type)]
#[repr(u32)]
pub enum SortOrder {
	Invalid,
	Canonical,
	Flow,
	Tab,
	ReverseCanonical,
	ReverseFlow,
	ReverseTab,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize, Type)]
#[repr(u32)]
pub enum TreeTraversalType {
	RestrictChildren,
	RestrictSibling,
	InOrder,
}

/// Used by `MatchRule` to define how to specify `Accessible`s.
// according to the XML this is has a signed representation.
#[non_exhaustive]
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Serialize, Deserialize, Type)]
#[repr(i32)]
pub enum MatchType {
	///  Indicates an error condition or uninitialized value.
	Invalid,
	///  Match if all criteria are met.
	#[default]
	All,
	/// Match if any one of the criteria is met.
	Any,
	/// Match if none of the criteria are met.
	NA,
	/// Same as `All` if the criteria are non-empty,
	/// for empty criteria, this rule requires an empty set to be returned.
	Empty,
}

#[atspi_proxy(interface = "org.a11y.atspi.Collection", assume_defaults = true)]
trait Collection {
	/// GetActiveDescendant method
	fn get_active_descendant(&self) -> zbus::Result<(String, zbus::zvariant::OwnedObjectPath)>;

	/// GetMatches method
	fn get_matches(
		&self,
		rule: &MatchRule,
		sortby: SortOrder,
		count: i32,
		traverse: bool,
	) -> zbus::Result<Vec<(String, zbus::zvariant::OwnedObjectPath)>>;

	/// GetMatchesFrom method
	fn get_matches_from(
		&self,
		current_object: &zbus::zvariant::ObjectPath<'_>,
		rule: &MatchRule,
		sortby: SortOrder,
		tree: TreeTraversalType,
		count: i32,
		traverse: bool,
	) -> zbus::Result<Vec<(String, zbus::zvariant::OwnedObjectPath)>>;

	/// GetMatchesTo method
	fn get_matches_to(
		&self,
		current_object: &zbus::zvariant::ObjectPath<'_>,
		rule: &MatchRule,
		sortby: SortOrder,
		tree: TreeTraversalType,
		limit_scope: bool,
		count: i32,
		traverse: bool,
	) -> zbus::Result<Vec<(String, zbus::zvariant::OwnedObjectPath)>>;
}
